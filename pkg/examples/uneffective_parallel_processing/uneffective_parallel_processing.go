package uneffectiveparallelprocessing

import (
	"fmt"
	"threadpool_example/pkg/data"
)

// Неэффективная реализация обработки данных. Улучшения:
//   - Хоть и неэффективное, но использование многопоточной обработки, что зачастую будет
//     затрачивать больше ресурсов при меньшей эффективности и скорости
//
// Проблемы:
//   - Неэффективное использование ресурсов - создание горутины на каждое входящее значение
//   - Неосвобождение ресурсов - каналы не закрываются
//   - Использование цикла по размеру входного среза вместо итерации по результирующему каналу,
//     что не позволяет работать с потоковыми данными
//   - Отсутствие контроля над исполнением - горутины никак не сигнализируют о своем состоянии
func RunBaseExample() {

	fmt.Println("Запуск примера с неэффективной обработкой...")

	const inputSize = 1_000_000
	fmt.Printf("Кол-во значение: %d\n", inputSize)

	resChan := make(chan int)
	ints := data.GenerateInts(inputSize)

	for _, value := range *ints {
		// Запуск отдельной горутины для каждого значения
		go func(value int) {
			// Запись результатов в канал
			resChan <- value * 2
		}(value)
	}

	extracted := 0
	// Цикл по размеру входных данных
	for range inputSize {
		_ = <-resChan
		extracted++
	}
	fmt.Printf("Обработано %d значений\n", extracted)
}
