package workersprocessing

import (
	"fmt"
	"sync"
	"threadpool_example/pkg/data"
)

// Более эффективная обработка данных использующая воркеры. Улучшения:
//   - Использование фиксированного числа горутин, что  повышает эффективность использования ресурсов,
//     избавляет программу от неконтролируемого роста горутин
//   - Освобождение ресурсов - закрытие каналов по окончанию записи в них
//   - Использования итераторов по каналам, что дает возможность работы с потоковыми данными
//   - Контроль выполнения горутин с помощью sync.WaitGroup - пока все воркеры не завершат работу,
//     выходной канал не будет закрыт, следовательно для окончания итерации по выходному каналу нужно
//     его закрыть и прочитать все значения из него
//
// Проблемы:
//   - Использование небуферизированных каналов, что вынуждает синхронизировать каждую запись и чтение в канал
//     с обеих сторон, может оказывать влияние на производительность
func RunBaseExample() {

	fmt.Println("Запуск примера с обработкой воркерами...")

	const inputSize = 1_000_000
	const workersCount = 5

	fmt.Printf("Кол-во значений: %d, кол-во воркеров: %d\n", inputSize, workersCount)

	inputChan := make(chan int)
	resChan := make(chan int)
	wg := &sync.WaitGroup{}

	// Запуск отдельной горутины для записи значений во входящий канал
	go func() {
		for _, value := range *data.GenerateInts(inputSize) {

			// Производится синхронизация писателя и читателя
			inputChan <- value
		}
		// Закрытие канала после окончания записи
		close(inputChan)
		fmt.Println("Канал для записи закрыт")
	}()

	// Запуск фиксированного количества горутин-воркеров
	for range workersCount {
		wg.Add(1)
		go func() {
			defer wg.Done()
			// Чтение из входного канала и запись в выходной
			for value := range inputChan {

				// Производится синхронизация писателя и читателя
				resChan <- value * 2
			}
		}()
	}

	go func() {
		// Ожидание завершения работы воркеров для закрытия выходного канала
		wg.Wait()
		close(resChan)
		fmt.Println("Канал для чтения закрыт")
	}()

	extracted := 0
	// Чтение значений из канала
	for value := range resChan {
		_ = value
		extracted++
	}
	fmt.Printf("Обработано %d значений\n", extracted)
}
