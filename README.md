# Threadpool
---

### Для реализации современных высокопроизводительных систем используются различные методики, которые позволяют нивелировать задержки в узких местах таких систем. Одной из таких техник является пул потоков.

Он решает сразу 2 проблемы:
1. Неэффективное использование оперативной памяти компьютера, скорость работы которой является узким местом по отношению к скорости процессора.
2. Неэффективное использование ресурсов процессора, когда создается слишком много задач, распределение которых по логическим ядрам требует слишком много процессорного времени на постоянное переключение контекста для обеспечения каждого потока некоторым количеством процессорного времени.

### В рамках рантайма golang используются горутины, то есть легковесные (green) потоки, которые имеют значительно более скромные требования к ресурсам по памяти и переключению контекста, но несмотря на это использование threadpool позволяет значительно уменьшить потребление ресурсов.

Несмотря на то, что рантайм go позволяет нам создавать огромное количество горутин (**G** согласно модели планировщика golang), физически одновременно и с максимальной эффективностью смогут исполняться не более чем ```runtime.GOMAXPROC()```, а на практике всегда меньше, поскольку как сам рантайм также создает служебные горутины, так и процессы, которые создает и использует рантайм (**P** согласно модели планировщика golang), сами лежат на процессах операционной системы (**M** согласно модели планировщика golang), планировщик которой также должен выделять процессорное время на все процессы операционной системы, коих может быть немало (>200).

*Однако стоит заметить, что в реальных системах зачастую узким местом становяться именно IO-bound задачи, то есть задачи на взаимодействие с внешними устройствами, например с файловой системой или с сокетами по сети, что позволяет эффективно использовать большее количество горутин, чем ```runtime.GOMAXPROC()```*

Однако в случае с большим количеством горутин, которые очень часто создаются и запускаются, например, при чтении из канала и запуске горутины для каждого прочитанного значения, скорость выполнения и потребления памяти могут сильно увеличиться, а эффективность планировщика снизиться. Модель потокобезопасного чтения данных из каналов в golang позволяет нескольким горутинам одновременно "висеть" на канале и безопасно читать данные из него с гарантией, что каждое значение из канала будет обработано только 1 раз, организуя такое чтение в виде цикла, что позволяет избежать некотролируемого снижения производительности и увеличения используемого объема памяти, которое будет зависеть от количества полученных задач. Стоит также отметить, что несмотря на то, что операция запуска горутины гораздо легковеснее, чем запуск потока операционной системы, она все равно гораздо более тяжелая, чем операция чтения из канала.


## Описание реализаций
Неэффективная реализация пула потоков находится в файле [badthreadpool.go](threadpool/bad/badthreadpool.go), она рассчитана на указания размера (фактически, размера буферизированных каналов) очереди входящих и исходящих задач.
Эффективная реализация пула потоков находится в файле [goodthreadpool.go](threadpool/good/goodthreadpool.go), она рассчитана на указание количества воркеров при инициализации пула функцией NewThreadPool. Размер очедерей при этом является число воркеров, умноженным на коэффициент chanSizeMult.

Обе реализации используют интерфейс ThreadPool из файла [threadpool.go](threadpool/threadpool.go), а также тип ApplierFunc для определения функции, которая будет использована в качестве обработчика. Интерфейс и, как следствие, реализации подразумевает работу с generic типами.

## Тесты производительности
В тестах производительности в качестве generic типов используются ```[int, int]```, что позволяет при работе с пулом получать и возвращать значения типа ```int```.

Для удобства тестирования используется утилита make и следующие комады, описанные в [файле](Makefile):
- make bench - классический запуск бенчмарк тестов для полного результатов тестирования обеих реализаций
- make verify - запуск бенчмарк тестов с падением в случае превышения лимита по используемым горутинам

## Результаты тестирования


## ```make bench```

```shell
go test ./... -bench=./.. -benchmem
?       threadpool_example      [no test files]
?       threadpool_example/threadpool   [no test files]
goos: linux
goarch: amd64
pkg: threadpool_example/threadpool/bad
cpu: AMD Ryzen 5 5600X 6-Core Processor             
BenchmarkBadThreadPool/2_queue_size_5000_values-12              1000000000               0.001961 ns/op        0 B/op          0 allocs/op
BenchmarkBadThreadPool/10_queue_size_100000_values-12           1000000000               0.02949 ns/op         0 B/op          0 allocs/op
BenchmarkBadThreadPool/12_queue_size_1000000_values-12          1000000000               0.2865 ns/op          0 B/op          0 allocs/op
PASS
ok      threadpool_example/threadpool/bad       4.852s
goos: linux
goarch: amd64
pkg: threadpool_example/threadpool/good
cpu: AMD Ryzen 5 5600X 6-Core Processor             
BenchmarkGoodThreadpool/2_workers_5000_values-12                1000000000               0.0006201 ns/op       0 B/op          0 allocs/op
BenchmarkGoodThreadpool/10_workers_100000_values-12             1000000000               0.01128 ns/op         0 B/op          0 allocs/op
BenchmarkGoodThreadpool/12_workers_1000000_values-12            1000000000               0.1111 ns/op          0 B/op          0 allocs/op
PASS
ok      threadpool_example/threadpool/good      1.212s
```

Хорошо заметна разница во времени на операцию, которая составляет в среднем c 2.8 раза в пользу эффективной реализации.


## ```make verify```

```shell
go test ./... -bench=./.. -benchmem -trackGoroCount
?       threadpool_example      [no test files]
?       threadpool_example/threadpool   [no test files]
--- FAIL: BenchmarkBadThreadPool/2_queue_size_5000_values
    badthreadpool_test.go:54: to many goroutines in use: 9 goroutines with 2 queue size
--- FAIL: BenchmarkBadThreadPool/10_queue_size_100000_values
    badthreadpool_test.go:54: to many goroutines in use: 16 goroutines with 10 queue size
--- FAIL: BenchmarkBadThreadPool/12_queue_size_1000000_values
    badthreadpool_test.go:54: to many goroutines in use: 26 goroutines with 12 queue size
--- FAIL: BenchmarkBadThreadPool
FAIL
exit status 1
FAIL    threadpool_example/threadpool/bad       0.004s
goos: linux
goarch: amd64
pkg: threadpool_example/threadpool/good
cpu: AMD Ryzen 5 5600X 6-Core Processor             
BenchmarkGoodThreadpool/2_workers_5000_values-12                1000000000               0.0006357 ns/op       0 B/op          0 allocs/op
BenchmarkGoodThreadpool/10_workers_100000_values-12             1000000000               0.01350 ns/op         0 B/op          0 allocs/op
BenchmarkGoodThreadpool/12_workers_1000000_values-12            1000000000               0.1260 ns/op          0 B/op          0 allocs/op
PASS
ok      threadpool_example/threadpool/good      1.521s
FAIL
make: *** [Makefile:7: verify] Error 1
```

В данном тесте присутствуют ошибки при тестировании неэффективной реализации, которая запускает слишком много горутин.








